<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMA Earthquake Activity Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--primary-navy) 0%, var(--primary-blue) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            margin: 0 auto;
        }

        .header {
            background: var(--bg-primary);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px var(--shadow-medium);
            text-align: center;
            border: 1px solid var(--border-light);
        }

        .header h1 {
            color: var(--primary-navy);
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header .subtitle {
            color: var(--text-secondary);
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #ecf0f1;
            border-radius: 25px;
            font-size: 0.9em;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #27ae60;
        }

        .loading {
            background: #f39c12;
        }

        .error {
            background: #e74c3c;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .controls h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5em;
            font-weight: 400;
        }

        .filter-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-btn {
            padding: 10px 20px;
            border: 2px solid #3498db;
            background: transparent;
            color: #3498db;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
        }

        .filter-btn:hover {
            background: #3498db;
            color: white;
        }

        .filter-btn.active {
            background: #3498db;
            color: white;
        }

        .refresh-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s ease;
            }

        .refresh-btn:hover {
            background: #229954;
            transform: translateY(-2px);
        }

        .content {
            display: block;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .panel h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }

        .earthquake-icon {
            background: #e74c3c;
        }

        .volcano-icon {
            background: #e67e22;
        }

        .event-item {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .event-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .event-item.earthquake {
            border-left-color: #e74c3c;
        }

        .event-item.volcano {
            border-left-color: #e67e22;
        }

        .event-item.level-3 {
            border-left-color: #e74c3c;
            border-left-width: 6px;
        }

        .event-item.level-2 {
            border-left-color: #f39c12;
            border-left-width: 5px;
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .event-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .event-time {
            font-size: 0.85em;
            color: #7f8c8d;
            white-space: nowrap;
        }

        .event-content {
            color: #5a6c7d;
            line-height: 1.5;
        }

        .alert-level {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            color: white;
            margin-top: 8px;
        }

        .alert-level-3 {
            background: #e74c3c;
        }

        .alert-level-2 {
            background: #f39c12;
        }

        .alert-level-1 {
            background: #27ae60;
        }

        .no-data {
            text-align: center;
            color: #7f8c8d;
            padding: 40px;
            font-style: italic;
        }

        .error-message {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: #3498db;
        }

        .stat-number {
            font-size: 2em;
            font-weight: 700;
            color: #2c3e50;
            display: block;
        }

        .stat-label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }

        /* Chart Styles */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }

        .bar-chart {
            display: flex;
            align-items: flex-end;
            height: 200px;
            gap: 8px;
            padding: 10px 0;
            border-bottom: 2px solid #ecf0f1;
        }

        .bar {
            flex: 1;
            background: linear-gradient(to top, #3498db, #5dade2);
            border-radius: 4px 4px 0 0;
            position: relative;
            min-height: 10px;
            transition: all 0.3s ease;
        }

        .bar:hover {
            background: linear-gradient(to top, #2980b9, #3498db);
            transform: translateY(-2px);
        }

        .bar-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #7f8c8d;
            font-weight: 600;
        }

        .bar-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #2c3e50;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* .magnitude-bar {
            background: linear-gradient(to top, #e74c3c, #ec7063);
        }

        .magnitude-bar:hover {
            background: linear-gradient(to top, #c0392b, #e74c3c);
        }

        .intensity-bar {
            background: linear-gradient(to top, #f39c12, #f7c52d);
        }

        .intensity-bar:hover {
            background: linear-gradient(to top, #e67e22, #f39c12);
        } */

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            line-height: 1.3;
        }

        .close-btn {
            background: #e74c3c;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
            margin-left: 15px;
        }

        .close-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        .modal-body {
            color: #5a6c7d;
            line-height: 1.6;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            padding: 10px 0;
            border-bottom: 1px solid #f8f9fa;
        }

        .detail-label {
            font-weight: 600;
            color: #2c3e50;
            min-width: 120px;
            flex-shrink: 0;
        }

        .detail-value {
            flex: 1;
            text-align: right;
            word-break: break-word;
        }

        .modal-content-text {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            font-size: 0.9em;
        }

        .modal-alert-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            color: white;
            margin-top: 10px;
        }

        .external-link {
            display: inline-block;
            margin-top: 15px;
            padding: 10px 20px;
            background: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .external-link:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .event-type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            color: white;
            margin-bottom: 10px;
        }

        .badge-earthquake {
            background: #e74c3c;
        }

        .badge-volcano {
            background: #e67e22;
        }

        .badge-other {
            background: #7f8c8d;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-30px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🏔️ 地震</h1>
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">Ready</span>
                </div>
                <div class="status-item">
                    <span>Last Updated: </span>
                    <span id="last-updated">Never</span>
                </div>
                <div class="status-item">
                    <span>Feed Status: </span>
                    <span id="feed-status">Disconnected</span>
                </div>
                <button class="refresh-btn" onclick="fetchJMAData()">
                    <span class="loading-spinner" id="loading-spinner" style="display: none;"></span>
                    <span id="refresh-icon">🔄</span> Refresh Data 
                </button>
            </div>
        </div>
        <div id="error-container"></div>

        <div class="controls">
            <div>
                <div class="filter-group">
                    <button class="filter-btn active" onclick="setFilter('all')">すべて(<span id="total-events">0</span>)</button>
                    <button class="filter-btn" onclick="setFilter('magnitude-5')">マグニチュード5以上(<span id="magnitude5-count">0</span>)</button>
                    <button class="filter-btn" onclick="setFilter('intensity-3')">震度3以上(<span id="intensity3-count">0</span>)</button>
                </div>
            </div>
        </div>
        <div class="content">
            <div class="panel">
                <h2>
                    <div class="panel-icon earthquake-icon"></div>
                    一覧
                </h2>
                <div id="earthquake-list">
                    <div class="no-data">Loading earthquake data...</div>
                </div>
            </div>
        </div>
        <div class="panel">

            <div class="charts-grid">
                <div class="chart-container">
                    <div class="chart-title">最大震度の傾向</div>
                    <div id="intensity-chart" class="bar-chart"></div>
                </div>
            </div>
            <div class="charts-grid" style="display: none;">
                <div class="chart-container">
                    <div class="chart-title">地震の規模の傾向</div>
                    <div id="magnitude-chart" class="bar-chart"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for event details -->
    <div id="event-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modal-title">Event Details</h2>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Event details will be populated here -->
            </div>
        </div>
    </div>

    <script>
        let currentFilter = 'all';
        let allEvents = [];
        let isLoading = false;
            const intensityColors = {
                '1': '#F2F2FF',
                '2': '#00AAFF',
                '3': '#0041FF',
                '4': '#FAE696',
                '5-': '#FAF500',
                '5+': '#FF9900',
                '6-': '#FF2800',
                '6+': '#A50021',
                '7': '#B40068'
            };
        // CORS proxy service for fetching JMA XML data
        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
        const JMA_FEED_URL = 'https://www.data.jma.go.jp/developer/xml/feed/eqvol.xml';

        async function fetchJMAData() {
            if (isLoading) return;

            isLoading = true;
            updateStatus('loading', 'Loading...');

            try {
                console.log('Starting to fetch JMA data...');
                const response = await fetch(CORS_PROXY + encodeURIComponent(JMA_FEED_URL));

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const xmlText = await response.text();
                console.log('XML text fetched, length:', xmlText.length);
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                // Check for XML parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('XML parsing error: ' + parseError.textContent);
                }

                const entries = xmlDoc.querySelectorAll('entry');
                console.log('Found entries:', entries.length);
                const events = [];

                entries.forEach(entry => {
                    const title = entry.querySelector('title')?.textContent || 'Unknown';
                    const content = entry.querySelector('content')?.textContent || '';
                    const updated = entry.querySelector('updated')?.textContent || '';
                    const id = entry.querySelector('id')?.textContent || '';
                    const author = entry.querySelector('author name')?.textContent || '';

                    // Determine event type
                    let type = 'other';
                    let alertLevel = null;

                    if (title.includes('震源・震度')) {
                        type = 'earthquake';
                    }

                    events.push({
                        title,
                        content,
                        updated,
                        id,
                        author,
                        type,
                        alertLevel,
                        timestamp: new Date(updated).getTime()
                    });
                });

                // Sort by timestamp (newest first)
                events.sort((a, b) => b.timestamp - a.timestamp);

                // Filter only earthquake events
                const earthquakeEvents = events.filter(event => event.type === 'earthquake');
                console.log('Earthquake events found:', earthquakeEvents.length);

                // Gather details first, then group by EventID
                console.log('About to call gatherDetailsAndGroup...');
                const groupedEvents = await gatherDetailsAndGroup(earthquakeEvents);
                console.log('gatherDetailsAndGroup completed, result:', groupedEvents.length, 'events');

                allEvents = groupedEvents;
                updateDisplay();
                updateStatus('connected', 'Connected');
                updateStats();


                const feedUpdated = xmlDoc.querySelector('feed updated')?.textContent;
                if (feedUpdated) {
                    document.getElementById('last-updated').textContent =
                        new Date(feedUpdated).toLocaleString();
                }

                document.getElementById('feed-status').textContent = 'Connected';
                clearErrors();

            } catch (error) {
                console.error('Error in fetchJMAData:', error);
                console.error('Error stack:', error.stack);
                updateStatus('error', 'Connection Error');
                document.getElementById('feed-status').textContent = 'Error';
                showError('Failed to fetch data: ' + error.message + ' (Check browser console for details)');
            } finally {
                isLoading = false;
            }
        }

        function updateStatus(status, text) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            statusDot.className = `status-dot ${status}`;
            statusText.textContent = text;
        }

        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `
                <div class="error-message">
                    <strong>Error:</strong> ${message}
                    <br><small>Note: This viewer requires internet access and may be affected by CORS policies. 
                    For production use, implement a server-side proxy.</small>
                </div>
            `;
        }

        function clearErrors() {
            document.getElementById('error-container').innerHTML = '';
        }

        function updateDisplay() {
            const earthquakeList = document.getElementById('earthquake-list');

            const filteredEvents = allEvents.filter(event => {
                const now = new Date();
                const eventTime = new Date(event.updated);
                const timeDiff = now - eventTime;
                const hoursAgo = timeDiff / (1000 * 60 * 60);

                if (currentFilter === 'all') return true;
                if (currentFilter === 'magnitude-5') {
                    // Will be determined from detailed XML data
                    return event.magnitude >= 5.0;
                }
                if (currentFilter === 'intensity-3') {
                    // Convert JMA intensity scale to numeric for comparison
                    const intensityToNum = {
                        '1': 1, '2': 2, '3': 3, '4': 4,
                        '5-': 5, '5+': 5.5, '6-': 6, '6+': 6.5, '7': 7
                    };
                    const numIntensity = intensityToNum[event.maxIntensity];
                    return numIntensity && numIntensity >= 3;
                }
                if (currentFilter === 'intensity-3') {
                    // Convert JMA intensity scale to numeric for comparison
                    const intensityToNum = {
                        '1': 1, '2': 2, '3': 3, '4': 4,
                        '5-': 5, '5+': 5.5, '6-': 6, '6+': 6.5, '7': 7
                    };
                    const numIntensity = intensityToNum[event.maxIntensity];
                    return numIntensity && numIntensity >= 4;
                }
                if (currentFilter === 'recent') return hoursAgo <= 24;
                return true;
            });

            // Update earthquake list
            if (filteredEvents.length === 0) {
                earthquakeList.innerHTML = '<div class="no-data">No earthquake data matching current filter</div>';
            } else {
                earthquakeList.innerHTML = filteredEvents.map(event => createEarthquakeHTML(event)).join('');
            }
        }

        function createEarthquakeHTML(event) {
            const date = new Date(event.updated);
            const timeStr = date.toLocaleString();
            const relativeTime = getRelativeTime(date);

            // Extract basic info from content or use placeholders
            const hypocenter = event.hypocenter || 'Loading...';
            const magnitude = event.magnitude ? `M${event.magnitude}` : 'Loading...';
            const maxIntensity = event.maxIntensity ? `震度${event.maxIntensity}` : 'Loading...';

            // Add report count indicator if multiple reports exist
            let reportCountBadge = '';
            if (event.reportCount && event.reportCount > 1) {
                reportCountBadge = `<div style="margin-top: 8px; display: inline-block; background: #3498db; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.7em; font-weight: 600;">
                    📄 ${event.reportCount} reports
                </div>`;
            }
            // border-left-color based on intensity intensitycolors, calculate color based on maxIntensity
            const byintensityColor = intensityColors[event.maxIntensity] || '#3498db'; 

            return `
                <div class="event-item" onclick="openModal('${event.id}')" style="cursor: pointer;border-left-color: ${byintensityColor}">
                    <div class="event-title">
                    ${event.content}
                    </div>

                    <div style="display: block; gap: 15px; margin: 10px 0;">
                        <div>発生時刻 ${new Date(event.originTime).toLocaleString()}</div>
                            <div>震源 ${hypocenter}</div>
                            <div>深さ ${event.depth ? event.depth + ' km' : '不明'}</div>
                            <div>地震の規模 ${magnitude}</div>
                            <div>最大震度 ${maxIntensity}</div>
                            <divコメント ${event.comment ? event.comment : "なし"}</div>
                    </div>
                </div>
            `;
        }

        function getRelativeTime(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);

            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return `${days}d ago`;
        }

        // Function to extract detailed information from earthquake XML
        async function extractEarthquakeDetails(event) {
            if (!event.id) return event;

            try {
                const response = await fetch(CORS_PROXY + encodeURIComponent(event.id));
                if (!response.ok) return event;

                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                // Extract EventID from XML
                const eventIDElement = xmlDoc.querySelector('EventID');
                if (eventIDElement) {
                    event.eventID = eventIDElement.textContent?.trim();
                }

                // Extract detailed earthquake information
                if (event.type === 'earthquake') {
                    // Extract hypocenter
                    const hypocenter = xmlDoc.querySelector('Hypocenter');
                    if (hypocenter) {
                        const area = hypocenter.querySelector('Area Name')?.textContent;
                        if (area) {
                            event.hypocenter = area;
                        }

                        // Extract coordinates and depth
                        const coordinate = hypocenter.querySelector('Coordinate');
                        if (coordinate) {
                            const latitude = coordinate.getAttribute('lat') || coordinate.textContent?.match(/\+([\d\.]+)/)?.[1];
                            const longitude = coordinate.getAttribute('lon') || coordinate.textContent?.match(/\+([\d\.]+)/g)?.[1]?.replace('+', '');
                            const depth = coordinate.getAttribute('depth') || coordinate.textContent?.match(/-([\d]+)/)?.[1];

                            if (latitude) event.latitude = parseFloat(latitude);
                            if (longitude) event.longitude = parseFloat(longitude);
                            if (depth) event.depth = parseInt(depth) / 1000; // Convert to km
                        }
                    }

                    // Extract magnitude
                    let magnitudeValue = null;
                    const jmxMagnitude = xmlDoc.querySelector('jmx_eb\\:Magnitude, Magnitude');
                    if (jmxMagnitude) {
                        magnitudeValue = jmxMagnitude.textContent?.trim();
                    }
                    if (!magnitudeValue) {
                        const earthquake = xmlDoc.querySelector('Earthquake');
                        if (earthquake) {
                            magnitudeValue = earthquake.getAttribute('mag');
                        }
                    }
                    if (magnitudeValue) {
                        const mag = parseFloat(magnitudeValue);
                        if (!isNaN(mag)) {
                            event.magnitude = mag;
                        }
                    }

                    // Extract maximum intensity and detailed observations
                    const intensityElements = xmlDoc.querySelectorAll('Intensity');
                    let maxIntensity = 0;
                    const intensityMap = {
                        '1': 1, '2': 2, '3': 3, '4': 4,
                        '5-': 5, '5+': 5.5, '6-': 6, '6+': 6.5, '7': 7
                    };
                    const intensityObservations = [];

                    intensityElements.forEach(intensity => {
                        const prefecture = intensity.querySelector('Pref Name')?.textContent;
                        const areas = intensity.querySelectorAll('Area');

                        areas.forEach(area => {
                            const areaName = area.querySelector('Name')?.textContent;
                            const intensityValue = area.querySelector('MaxInt')?.textContent;

                            if (intensityValue && intensityMap[intensityValue]) {
                                maxIntensity = Math.max(maxIntensity, intensityMap[intensityValue]);
                            }

                            const cities = area.querySelectorAll('City');
                            cities.forEach(city => {
                                const cityName = city.querySelector('Name')?.textContent;
                                const stations = city.querySelectorAll('IntensityStation');

                                stations.forEach(station => {
                                    const stationName = station.querySelector('Name')?.textContent;
                                    const stationInt = station.querySelector('Int')?.textContent;

                                    if (stationName && stationInt) {
                                        intensityObservations.push({
                                            prefecture: prefecture || '',
                                            area: areaName || '',
                                            city: cityName || '',
                                            station: stationName,
                                            intensity: stationInt
                                        });

                                        if (intensityMap[stationInt]) {
                                            maxIntensity = Math.max(maxIntensity, intensityMap[stationInt]);
                                        }
                                    }
                                });
                            });
                        });
                    });

                    if (maxIntensity > 0) {
                        // Convert back to JMA intensity scale
                        if (maxIntensity >= 7) event.maxIntensity = '7';
                        else if (maxIntensity >= 6.5) event.maxIntensity = '6強';
                        else if (maxIntensity >= 6) event.maxIntensity = '6弱';
                        else if (maxIntensity >= 5.5) event.maxIntensity = '5強';
                        else if (maxIntensity >= 5) event.maxIntensity = '5弱';
                        else if (maxIntensity >= 4) event.maxIntensity = '4';
                        else if (maxIntensity >= 3) event.maxIntensity = '3';
                        else if (maxIntensity >= 2) event.maxIntensity = '2';
                        else if (maxIntensity >= 1) event.maxIntensity = '1';
                        else event.maxIntensity = Math.floor(maxIntensity).toString();
                    }

                    if (intensityObservations.length > 0) {
                        event.intensityObservations = intensityObservations;
                    }

                    // Extract comments
                    const comments = xmlDoc.querySelectorAll('Comment');
                    const commentTexts = [];
                    comments.forEach(comment => {
                        const text = comment.querySelector('Text')?.textContent;
                        if (text && text.trim().length > 0) {
                            commentTexts.push(text.trim());
                        }
                    });
                    if (commentTexts.length > 0) {
                        event.comment = commentTexts[0]; // Use first comment for display
                        event.allComments = commentTexts; // Store all comments
                    }

                    // Extract origin time
                    const originTime = xmlDoc.querySelector('OriginTime')?.textContent;
                    if (originTime) {
                        event.originTime = originTime;
                        event.originTimestamp = new Date(originTime).getTime();
                    }

                    // Extract other useful information
                    const reportDateTime = xmlDoc.querySelector('ReportDateTime')?.textContent;
                    if (reportDateTime) {
                        event.reportDateTime = reportDateTime;
                    }

                    const infoType = xmlDoc.querySelector('InfoType')?.textContent;
                    if (infoType) {
                        event.infoType = infoType;
                    }

                    const serial = xmlDoc.querySelector('Serial')?.textContent;
                    if (serial) {
                        event.serial = parseInt(serial);
                    }
                }

                return event;

            } catch (error) {
                console.warn('Failed to fetch detailed info for:', event.id, error);
                return event;
            }
        }

        // Function to group events by EventID after details are extracted
        async function gatherDetailsAndGroup(events) {
            console.log(`Processing ${events.length} earthquake events...`);

            // Step 1: Gather detailed information for all events
            const detailedEvents = [];
            for (const event of events) {
                const detailedEvent = await extractEarthquakeDetails(event);
                detailedEvents.push(detailedEvent);
            }

            console.log('Details gathered, now grouping by EventID...');

            // Step 2: Group by EventID
            const groupedEvents = new Map();

            detailedEvents.forEach(event => {
                let eventId = event.eventID;

                // Fallback: use filename as event ID if EventID not found in XML
                if (!eventId && event.id) {
                    const filename = event.id.split('/').pop()?.replace('.xml', '');
                    if (filename) {
                        eventId = filename;
                    }
                }

                // Last fallback: use URL or title+timestamp
                if (!eventId) {
                    eventId = event.id || event.title + event.timestamp;
                }

                event.eventID = eventId;

                if (groupedEvents.has(eventId)) {
                    const existingEvent = groupedEvents.get(eventId);

                    // Determine which event to keep based on criteria:
                    // 1. Higher serial number (more recent report)
                    // 2. Later report time
                    // 3. Later timestamp
                    let keepNewEvent = false;

                    if (event.serial && existingEvent.serial) {
                        keepNewEvent = event.serial > existingEvent.serial;
                    } else if (event.reportDateTime && existingEvent.reportDateTime) {
                        keepNewEvent = new Date(event.reportDateTime) > new Date(existingEvent.reportDateTime);
                    } else {
                        keepNewEvent = event.timestamp > existingEvent.timestamp;
                    }

                    if (keepNewEvent) {
                        // Keep the new event, add report count
                        event.reportCount = (existingEvent.reportCount || 1) + 1;
                        event.allReports = [...(existingEvent.allReports || [existingEvent]), event];
                        groupedEvents.set(eventId, event);
                    } else {
                        // Keep the existing event, increment report count
                        existingEvent.reportCount = (existingEvent.reportCount || 1) + 1;
                        existingEvent.allReports = [...(existingEvent.allReports || [existingEvent]), event];
                        groupedEvents.set(eventId, existingEvent);
                    }
                } else {
                    // First time seeing this event ID
                    event.reportCount = 1;
                    event.allReports = [event];
                    groupedEvents.set(eventId, event);
                }
            });

            const result = Array.from(groupedEvents.values());

            // Sort by origin time (if available) or timestamp (newest first)
            result.sort((a, b) => {
                const aTime = a.originTimestamp || a.timestamp;
                const bTime = b.originTimestamp || b.timestamp;
                return bTime - aTime;
            });

            console.log(`Grouped ${detailedEvents.length} events into ${result.length} unique earthquakes`);
            return result;
        }

        function updateStats() {
            const magnitude5Plus = allEvents.filter(e => e.magnitude && e.magnitude >= 5.0);
            const intensity3Plus = allEvents.filter(e => {
                if (!e.maxIntensity) return false;
                const intensityToNum = {
                    '1': 1, '2': 2, '3': 3, '4': 4,
                    '5弱': 5, '5強': 5.5, '6弱': 6, '6強': 6.5, '7': 7
                };
                const numIntensity = intensityToNum[e.maxIntensity];
                return numIntensity && numIntensity >= 3;
            });
            const now = new Date();
            const recent = allEvents.filter(e => {
                const eventTime = new Date(e.updated);
                const hoursAgo = (now - eventTime) / (1000 * 60 * 60);
                return hoursAgo <= 24;
            });

            document.getElementById('total-events').textContent = allEvents.length;
            document.getElementById('magnitude5-count').textContent = magnitude5Plus.length;
            document.getElementById('intensity3-count').textContent = intensity3Plus.length;

            // Update charts
            updateCharts();
        }

        function updateCharts() {
            updateMagnitudeChart();
            updateIntensityChart();
        }

        function updateMagnitudeChart() {
            // bacolor according count, few #F2E700, much #F2A900, many #F25C00, very many #F20000
            const barcolor = {
                few: '#F2E700',
                much: '#F2A900',
                many: '#F25C00',
                veryMany: '#F20000'
            }
            const magnitudeChart = document.getElementById('magnitude-chart');

            // Count events by magnitude ranges
            const magRanges = {
                '< 3.0': 0,
                '3.0-3.9': 0,
                '4.0-4.9': 0,
                '5.0-5.9': 0,
                '6.0-6.9': 0,
                '≥ 7.0': 0
            };

            allEvents.forEach(event => {
                if (event.magnitude) {
                    const mag = event.magnitude;
                    if (mag < 3.0) magRanges['< 3.0']++;
                    else if (mag < 4.0) magRanges['3.0-3.9']++;
                    else if (mag < 5.0) magRanges['4.0-4.9']++;
                    else if (mag < 6.0) magRanges['5.0-5.9']++;
                    else if (mag < 7.0) magRanges['6.0-6.9']++;
                    else magRanges['≥ 7.0']++;
                }
            });

            const maxValue = Math.max(...Object.values(magRanges), 1);

            magnitudeChart.innerHTML = Object.entries(magRanges).map(([range, count]) => {
                const height = (count / maxValue) * 100;
                // define bar color by count from barcolor
                let barcolor = '#7f8c8d'; // default gray
                if (count < 5) barcolor = barcolor.few;
                else if (count < 10) barcolor = barcolor.much;
                else if (count < 30) barcolor = barcolor.many;
                else barcolor = barcolor.veryMany;
                return `
                    <div class="bar magnitude-bar" style="height: ${height}%; background: ${barcolor}" title="${range}: ${count} events">
                        <div class="bar-value" style="display: ${count > 0 ? 'block' : 'none'}">${count}</div>
                        <div class="bar-label">${range}</div>
                    </div>
                `;
            }).join('');
        }

        function updateIntensityChart() {
            const intensityChart = document.getElementById('intensity-chart');

            // Count events by intensity levels
            const intensityRanges = {
                '1': 0,
                '2': 0,
                '3': 0,
                '4': 0,
                '5-': 0,
                '5+': 0,
                '6-': 0,
                '6+': 0,
                '7': 0
            };

            allEvents.forEach(event => {
                if (event.maxIntensity) {
                    const intensity = event.maxIntensity;
                    if (intensityRanges.hasOwnProperty(intensity)) {
                        intensityRanges[intensity]++;
                    }
                }
            });

            const maxValue = Math.max(...Object.values(intensityRanges), 1);

            // Sort by intensity level
            intensityChart.innerHTML = Object.entries(intensityRanges).sort((a, b) => {
                const intensityOrder = {
                    '1': 1, '2': 2, '3': 3, '4': 4,
                    '5-': 5, '5+': 6, '6-': 7, '6+': 8, '7': 9
                };
                return intensityOrder[a[0]] - intensityOrder[b[0]];
            }).map(([intensity, count]) => {
                const height = (count / maxValue) * 100;
                const color = intensityColors[intensity] || '#7f8c8d';
                return `
                    <div class="bar intensity-bar" style="height: ${height}%; background: linear-gradient(to top, ${color}, ${color}aa)" title="Intensity ${intensity}: ${count} events">
                        <div class="bar-value">${count}</div>
                        <div class="bar-label">${intensity}</div>
                    </div>
                `;
            }).join('');
        }



        function setFilter(filter) {
            currentFilter = filter;

            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            updateDisplay();
        }

        function refreshData() {
            const refreshIcon = document.getElementById('refresh-icon');
            refreshIcon.style.animation = 'spin 1s linear infinite';

            fetchJMAData().finally(() => {
                setTimeout(() => {
                    refreshIcon.style.animation = '';
                }, 1000);
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            fetchJMAData();

            // Auto-refresh every 5 minutes
            setInterval(fetchJMAData, 5 * 60 * 1000);
        });

        // Handle online/offline status
        window.addEventListener('online', () => {
            updateStatus('connected', 'Back Online');
            fetchJMAData();
        });

        window.addEventListener('offline', () => {
            updateStatus('error', 'Offline');
        });

        // Modal functions
        async function openModal(eventId) {
            const event = allEvents.find(e => e.id === eventId);
            if (!event) return;

            const modal = document.getElementById('event-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            // Set modal title
            modalTitle.textContent = event.title;

            // Create event type badge
            const typeBadge = `<div class="event-type-badge badge-${event.type}">
                ${event.type.charAt(0).toUpperCase() + event.type.slice(1)} Event
            </div>`;

            // Create alert level badge if applicable
            let alertBadge = '';
            if (event.alertLevel) {
                const alertColors = {
                    1: '#27ae60',
                    2: '#f39c12',
                    3: '#e74c3c'
                };
                alertBadge = `<div class="modal-alert-badge" style="background: ${alertColors[event.alertLevel]}">
                    Volcanic Alert Level ${event.alertLevel}
                </div>`;
            }

            // Format dates
            const eventDate = new Date(event.updated);
            const formattedDate = eventDate.toLocaleString('ja-JP', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            });
            const relativeTime = getRelativeTime(eventDate);

            // Show loading state initially
            modalBody.innerHTML = `
                ${typeBadge}
                ${alertBadge}
                
                <div id="detailed-loading" style="text-align: center; margin: 20px 0;">
                    <div class="loading-spinner"></div>
                    <p style="margin-top: 10px;">Loading detailed information...</p>
                </div>
                
                <div id="detailed-content" style="display: none;"></div>
                
                ${event.id ? `<a href="${event.id}" target="_blank" class="external-link">
                    📄 View Raw XML Data
                </a>` : ''}
            `;

            // Show modal with animation
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';

            // Fetch detailed data from the event ID URL
            if (event.id) {
                try {
                    const detailResponse = await fetch(CORS_PROXY + encodeURIComponent(event.id));

                    if (detailResponse.ok) {
                        const detailXmlText = await detailResponse.text();
                        const detailParser = new DOMParser();
                        const detailXmlDoc = detailParser.parseFromString(detailXmlText, 'text/xml');

                        // Parse detailed information
                        const detailedInfo = parseDetailedXML(detailXmlDoc, event.type);

                        // Update modal with detailed information
                        const detailedContentDiv = document.getElementById('detailed-content');
                        const loadingDiv = document.getElementById('detailed-loading');

                        if (detailedInfo && Object.keys(detailedInfo).length > 0) {
                            detailedContentDiv.innerHTML = formatDetailedInfo(detailedInfo);
                            detailedContentDiv.style.display = 'block';
                            loadingDiv.style.display = 'none';
                        } else {
                            loadingDiv.innerHTML = '<p style="color: #f39c12;">⚠️ Detailed information not available</p>';
                        }
                    } else {
                        document.getElementById('detailed-loading').innerHTML =
                            '<p style="color: #e74c3c;">❌ Failed to load detailed information</p>';
                    }
                } catch (error) {
                    console.error('Error fetching detailed data:', error);
                    document.getElementById('detailed-loading').innerHTML =
                        '<p style="color: #e74c3c;">❌ Error loading detailed information</p>';
                }
            } else {
                document.getElementById('detailed-loading').style.display = 'none';
            }

            // Show modal with animation
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeModal() {
            const modal = document.getElementById('event-modal');
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        function getEventTypeDescription(type) {
            const descriptions = {
                'earthquake': '🏔️ Seismic Activity - Earthquake with epicenter and intensity information',
                'other': '📊 Other Event - General meteorological or geological information'
            };
            return descriptions[type] || 'Unknown event type';
        }

        // Close modal when clicking outside the modal content
        window.addEventListener('click', (event) => {
            const modal = document.getElementById('event-modal');
            if (event.target === modal) {
                closeModal();
            }
        });

        // Close modal with Escape key
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeModal();
            }
        });

        // Function to parse detailed XML information
        function parseDetailedXML(xmlDoc, eventType) {
            const details = {};

            try {
                // Common elements
                const reportDateTime = xmlDoc.querySelector('ReportDateTime')?.textContent;
                const targetDateTime = xmlDoc.querySelector('TargetDateTime')?.textContent;
                const eventID = xmlDoc.querySelector('EventID')?.textContent;
                const infoType = xmlDoc.querySelector('InfoType')?.textContent;
                const serial = xmlDoc.querySelector('Serial')?.textContent;
                const infoKind = xmlDoc.querySelector('InfoKind')?.textContent;

                if (reportDateTime) details.reportDateTime = reportDateTime;
                if (targetDateTime) details.targetDateTime = targetDateTime;
                if (eventID) details.eventID = eventID;
                if (infoType) details.infoType = infoType;
                if (serial) details.serial = serial;
                if (infoKind) details.infoKind = infoKind;

                if (eventType === 'earthquake') {
                    // Earthquake-specific parsing - enhanced for JMA XML structure

                    // Parse earthquake time
                    const originTime = xmlDoc.querySelector('OriginTime')?.textContent;
                    if (originTime) details.originTime = originTime;

                    // Parse hypocenter information
                    const hypocenter = xmlDoc.querySelector('Hypocenter');
                    if (hypocenter) {
                        const area = hypocenter.querySelector('Area Name')?.textContent;
                        const coordinate = hypocenter.querySelector('Coordinate');
                        if (coordinate) {
                            const latitude = coordinate.getAttribute('lat') || coordinate.textContent?.match(/\+([\d\.]+)/)?.[1];
                            const longitude = coordinate.getAttribute('lon') || coordinate.textContent?.match(/\+([\d\.]+)/g)?.[1]?.replace('+', '');
                            const depth = coordinate.getAttribute('depth') || coordinate.textContent?.match(/-([\d]+)/)?.[1];

                            if (latitude) details.latitude = latitude + '°N';
                            if (longitude) details.longitude = longitude + '°E';
                            if (depth) details.depth = (parseInt(depth) / 1000) + ' km';
                        }

                        if (area) details.epicenterArea = area;
                    }

                    // Parse magnitude - enhanced for JMA XML structure
                    let magnitudeValue = null;
                    let magnitudeType = null;

                    // Try to find jmx_eb:Magnitude element first
                    const jmxMagnitude = xmlDoc.querySelector('jmx_eb\\:Magnitude, Magnitude');
                    if (jmxMagnitude) {
                        magnitudeValue = jmxMagnitude.textContent?.trim();
                        magnitudeType = jmxMagnitude.getAttribute('type') || 'M';
                    }

                    // Fallback to Earthquake element
                    if (!magnitudeValue) {
                        const earthquake = xmlDoc.querySelector('Earthquake');
                        if (earthquake) {
                            magnitudeValue = earthquake.getAttribute('mag') || earthquake.textContent?.match(/([\d\.]+)/)?.[1];
                            magnitudeType = 'M';
                        }
                    }

                    if (magnitudeValue) {
                        const mag = parseFloat(magnitudeValue);
                        if (!isNaN(mag)) {
                            details.magnitude = `${magnitudeType}${mag}`;
                        }
                    }

                    // Parse intensity observations - enhanced for JMA structure
                    const intensityElements = xmlDoc.querySelectorAll('Intensity');
                    const intensityData = [];

                    intensityElements.forEach(intensity => {
                        const prefecture = intensity.querySelector('Pref Name')?.textContent;
                        const areas = intensity.querySelectorAll('Area');

                        areas.forEach(area => {
                            const areaName = area.querySelector('Name')?.textContent;
                            const intensityValue = area.querySelector('MaxInt')?.textContent;
                            const cities = area.querySelectorAll('City');

                            cities.forEach(city => {
                                const cityName = city.querySelector('Name')?.textContent;
                                const stations = city.querySelectorAll('IntensityStation');

                                stations.forEach(station => {
                                    const stationName = station.querySelector('Name')?.textContent;
                                    const stationInt = station.querySelector('Int')?.textContent;

                                    if (stationName && stationInt) {
                                        intensityData.push({
                                            prefecture: prefecture || '',
                                            area: areaName || '',
                                            city: cityName || '',
                                            station: stationName,
                                            intensity: stationInt
                                        });
                                    }
                                });

                                // If no stations, add city-level data
                                if (cities.length === 0 && cityName && intensityValue) {
                                    intensityData.push({
                                        prefecture: prefecture || '',
                                        area: areaName || '',
                                        city: cityName,
                                        station: '',
                                        intensity: intensityValue
                                    });
                                }
                            });

                            // If no cities, add area-level data
                            if (cities.length === 0 && areaName && intensityValue) {
                                intensityData.push({
                                    prefecture: prefecture || '',
                                    area: areaName,
                                    city: '',
                                    station: '',
                                    intensity: intensityValue
                                });
                            }
                        });
                    });

                    if (intensityData.length > 0) details.intensityObservations = intensityData;

                    // Parse tsunami information
                    const tsunamiElement = xmlDoc.querySelector('Text');
                    if (tsunamiElement && tsunamiElement.textContent?.includes('津波')) {
                        details.tsunamiInfo = tsunamiElement.textContent;
                    }
                }

                // Parse additional text content
                const textElements = xmlDoc.querySelectorAll('Text');
                const textData = [];
                textElements.forEach(text => {
                    const content = text.textContent?.trim();
                    if (content && content.length > 10) {
                        textData.push(content);
                    }
                });
                if (textData.length > 0) details.additionalText = textData;
                const comments = xmlDoc.querySelectorAll('Comment');
                const commentData = [];
                comments.forEach(comment => {
                    const codeType = comment.querySelector('CodeType')?.textContent;
                    const text = comment.querySelector('Text')?.textContent;
                    if (text) {
                        commentData.push({ codeType, text });
                    }
                });
                if (commentData.length > 0) details.comments = commentData;

            } catch (error) {
                console.error('Error parsing detailed XML:', error);
            }

            return details;
        }

        // Function to format detailed information for display
        function formatDetailedInfo(details) {
            let html = '<h3 style="margin: 20px 0 15px 0; color: #2c3e50; border-bottom: 2px solid #ecf0f1; padding-bottom: 10px;">📊 Detailed Information</h3>';

            // Basic information
            if (details.originTime) {
                html += `<div class="detail-row"><span class="detail-label">Origin Time</span><span class="detaill-value">${new Date(details.originTime).toLocaleString()}</span></div>`;
                if (details.reportDateTime) {
                    html += `<div class="detail-row"><span class="detail-label">Report Time:</span><span class="detail-value">${new Date(details.reportDateTime).toLocaleString()}</span></div>`;
                }
                if (details.eventID) {
                    html += `<div class="detail-row"><span class="detail-label">Event ID:</span><span class="detail-value">${details.eventID}</span></div>`;
                }
                if (details.infoType) {
                    html += `<div class="detail-row"><span class="detail-label">Info Type:</span><span class="detail-value">${details.infoType}</span></div>`;
                }
                // Earthquake-specific information
                if (details.epicenterArea) {
                    html += `<div class="detail-row"><span class="detail-label">📍 Epicenter:</span><span class="detail-value">${details.epicenterArea}</span></div>
</div>`;
                }
                if (details.latitude && details.longitude) {
                    html += `<div class="detail-row"><span class="detail-label">🌐 Coordinates:</span><span class="detail-value">${details.latitude}, ${details.longitude}</span></div>`;
                }
                if (details.depth) {
                    html += `<div class="detail-row"><span class="detail-label">📏 Depth:</span><span class="detail-value">${details.depth}</span></div>`;
                }
                if (details.magnitude) {
                    html += `<div class="detail-row"><span class="detail-label">📊 Magnitude:</span><span class="detail-value">${details.magnitude}</span></div>`;
                }

                // Intensity observations - enhanced display
                if (details.intensityObservations && details.intensityObservations.length > 0) {
                    html += `<h4 style="margin: 15px 0 10px 0; color: #2c3e50;">🏘️ Seismic Intensity Observations(${details.intensityObservations.length})</h4>`;

                    // Group by prefecture for better organization
                    const groupedByPrefecture = {};
                    details.intensityObservations.forEach(obs => {
                        const pref = obs.prefecture || 'Other Areas';
                        if (!groupedByPrefecture[pref]) {
                            groupedByPrefecture[pref] = [];
                        }
                        groupedByPrefecture[pref].push(obs);
                    });

                    Object.keys(groupedByPrefecture).slice(0, 5).forEach(prefecture => {
                        const observations = groupedByPrefecture[prefecture];
                        // Determine color based on maximum intensity in this prefecture
                        const maxIntensity = Math.max(...observations.map(obs => parseFloat(obs.intensity) || 0));
                        // Display each observation
                        observations.slice(0, 8).forEach(obs => {
                            const intensityColors = {
                                '1': '#F2F2FF',
                                '2': '#00AAFF',
                                '3': '#0041FF',
                                '4': '#FAE696',
                                '5-': '#FAF500',
                                '5+': '#FF9900',
                                '6-': '#FF2800',
                                '6+': '#A50021',
                                '7': '#B40068'
                            };

                            const intensityColor = intensityColors[obs.intensity] || '#7f8c8d';
                            let locationName = '';

                            if (obs.station) {
                                locationName = obs.station;
                                if (obs.station.includes('*')) {
                                    locationName += ' <span style="font-size: 0.8em; color: #7f8c8d;">(非気象庁)</span>';
                                }
                            } else if (obs.city) {
                                locationName = obs.city;
                            } else if (obs.area) {
                                locationName = obs.area;
                            }
                            const intensitytextcolor = obs.intensity == 1 ? '#000000' : '#FFFFFF';

                            html += `<div style="margin: 4px 0; display: flex; justify-content: space-between; align-items: center;">`;
                            html += `<span style="font-size: 0.9em;">${locationName}</span>`;
                            html += `<span style="background: ${intensityColor}; color: ${intensitytextcolor}; padding: 2px 8px; border-radius: 12px; font-weight: 600; font-size: 0.8em;">震度${obs.intensity}</span>`;
                            html += `</div>`;
                        });

                        if (observations.length > 8) {
                            html += `<div style="font-style: italic; color: #7f8c8d; margin-top: 8px; font-size: 0.85em;">... and ${observations.length - 8} more stations in ${prefecture}</div>`;
                        }
                        html += '</div>';
                    });

                    const totalPrefectures = Object.keys(groupedByPrefecture).length;
                    if (totalPrefectures > 5) {
                        html += `<div style="text-align: center; margin: 10px 0; padding: 10px; background: #ecf0f1; border-radius: 8px; color: #7f8c8d; font-style: italic;">`;
                        html += `📊 Showing top 5 prefectures. Total: ${totalPrefectures} prefectures with ${details.intensityObservations.length} observation points`;
                        html += `</div>`;
                    }
                }

                // Tsunami information
                if (details.tsunamiInfo) {
                    html += '<h4 style="margin: 15px 0 10px 0; color: #2c3e50;">🌊 Tsunami Information</h4>';
                    html += `<div style="background: #e8f5e8; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #27ae60;">`;
                    html += `<div style="color: #27ae60; font-weight: 600;">${details.tsunamiInfo}</div>`;
                    html += `</div>`;
                }

                // Additional text without 0215 and 0262
                if (details.additionalText && details.additionalText.length > 0) {
                    html += '<h4 style="margin: 15px 0 10px 0; color: #2c3e50;">📝 Additional Information</h4>';
                    details.additionalText.forEach(text => {
                        html += `<div class="modal-content-text">${text}</div>`;
                    });
                }

                // Comments
                if (details.comments && details.comments.length > 0) {
                    html += '<h4 style="margin: 15px 0 10px 0; color: #2c3e50;">💬 Comments</h4>';
                    details.comments.forEach(comment => {
                        html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0;">';
                        if (comment.codeType) html += `<div style="font-weight: 600; color: #3498db; margin-bottom: 5px;">${comment.codeType}</div>`;
                        html += `<div>${comment.text}</div>`;
                        html += '</div>';
                    });
                }

                return html;
            }
        }
    </script>
</body>

</html>